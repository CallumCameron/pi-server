#!/bin/bash
# Main backup script

EMAIL_SCRIPT='@@@@@1@@@@@'
BACKUP_LOCK='@@@@@2@@@@@'
LAST_RUN_FILE='@@@@@3@@@@@'
DATA_DIR='@@@@@4@@@@@'
BACKUP_PARTITION='@@@@@5@@@@@'
SERVICES_DIR='@@@@@6@@@@@'
LOG='@@@@@7@@@@@'
GIT_BACKUP_CONFIG='@@@@@8@@@@@'
GIT_DIR='@@@@@9@@@@@'
GIT_SSH_SCRIPT='@@@@@10@@@@@'
APT_OUTPUT='@@@@@11@@@@@'
HAS_LOCK=''

function lock() {
    if mkdir "${BACKUP_LOCK}" &>/dev/null; then
        HAS_LOCK='t'
        return 0
    else
        return 1
    fi
}

function unlock() {
    if [ ! -z "${HAS_LOCK}" ] && [ -e "${BACKUP_LOCK}" ]; then
        rmdir "${BACKUP_LOCK}"
    fi
}

function start-services() {
    /usr/sbin/service supervisor restart &>> "${LOG}"
    /usr/sbin/service nginx restart &>> "${LOG}"
    find "${SERVICES_DIR}" -type f | LC_ALL=C sort | while read line; do
        /usr/sbin/service "$(basename "${line}")" restart &>> "${LOG}"
    done
}

function stop-services() {
    /usr/sbin/service supervisor stop &>> "${LOG}"
    /usr/sbin/service nginx stop &>> "${LOG}"
    find "${SERVICES_DIR}" -type f | LC_ALL=C sort | while read line; do
        /usr/sbin/service "$(basename "${line}")" stop &>> "${LOG}"
    done
}

function cleanup() {
    if [ ! -z "${HAS_LOCK}" ]; then
        sync
        if mount | grep "${BACKUP_PARTITION}" &>/dev/null; then
            umount "${BACKUP_PARTITION}"
        fi
        start-services
        unlock
    fi
}

function fail() {
    "${EMAIL_SCRIPT}" 'Backup failed' "${@}"
    if [ ! -z "${HAS_LOCK}" ]; then
        echo "${@}" >> "${LOG}"
    fi
    cleanup
    exit 1
}


if [ "$(id -u)" != '0' ]; then
    fail 'Backup script must be run as root.'
fi

if ! lock; then
    fail 'Tried to backup when another backup is already running.'
fi

:> "${LOG}"

if [ ! -e "${DATA_DIR}" ]; then
    fail 'Data directory does not exist.'
fi

if ! mount | grep "${BACKUP_PARTITION}" &>/dev/null; then
    if ! mount "${BACKUP_PARTITION}" &>/dev/null; then
        fail 'Cannot mount backup partition.'
    fi
fi

stop-services &&


# Main backup
echo "Main backup started at $(date)" >> "${LOG}" &&

TODAY="$(date '+%Y-%m-%d')" &&
DAY_OF_WEEK="$(date '+%u')" &&
DAY_OF_MONTH="$(date '+%d')" || fail 'Something went wrong.'

if [ ! -e "${LAST_RUN_FILE}" ] || [ "${TODAY}" != "$(cat "${LAST_RUN_FILE}")" ]; then
    echo "${TODAY}" > "${LAST_RUN_FILE}" &&

    rsnapshot daily &>> "${LOG}" || fail 'Daily backup failed.'
    echo 'Daily backup succeeded.' >> "${LOG}"

    if [ "${DAY_OF_WEEK}" == '1' ]; then
        rsnapshot weekly &>> "${LOG}" || fail 'Weekly backup failed.'
        echo 'Weekly backup succeeded.' >> "${LOG}"
    fi

    if [ "${DAY_OF_MONTH}" == '1' ]; then
        rsnapshot monthly &>> "${LOG}" || fail 'Monthly backup failed.'
        echo 'Monthly backup succeeded.' >> "${LOG}"
    fi

    sync
else
    echo 'Already backed up today; nothing to do for main backup.' >> "${LOG}"
fi

echo "Main backup finished at $(date)" >> "${LOG}" &&


# Git backup
echo "Git backup started at $(date)" >> "${LOG}" &&

if [ -f "${GIT_BACKUP_CONFIG}" ]; then
    while read line; do
        REPO_PATH="${GIT_DIR}/$(basename "${line}" '.git')"
        if [ ! -e "${REPO_PATH}" ]; then
            echo "Cloning to ${REPO_PATH}..." >> "${LOG}"
            cd /
            su -s /bin/bash -c "export GIT_SSH='${GIT_SSH_SCRIPT}' && git clone --mirror '${line}' '${REPO_PATH}'" www-data &>> "${LOG}" || fail 'Cloning a repository failed.'
            echo "Cloned to ${REPO_PATH}." >> "${LOG}"
        else
            echo "Updating ${REPO_PATH}..." >> "${LOG}"
            cd /
            su -s /bin/bash -c "export GIT_SSH='${GIT_SSH_SCRIPT}' && cd '${REPO_PATH}' && git fetch --all && git fetch --all --tags" www-data &>> "${LOG}" || fail 'Fetching a repository failed.'
            echo "Updated ${REPO_PATH}." >> "${LOG}"
        fi
    done < "${GIT_BACKUP_CONFIG}"
fi

echo "Git backup finished at $(date)" >> "${LOG}" &&


# TODO email


# Updates
echo "Updates started at $(date)" >> "${LOG}" &&

apt-get update &>> "${LOG}" &&
GIT_AUTHOR_NAME='root' GIT_AUTHOR_EMAIL="root@$(hostname)" GIT_COMMITTER_NAME='root' GIT_COMMITTER_EMAIL="root@$(hostname)" DEBIAN_FRONTEND='noninteractive' apt-get -y upgrade 2>&1 | tee "${APT_OUTPUT}" >> "${LOG}" &&

UPDATED="$(grep -o '[0-9]\+ upgraded' "${APT_OUTPUT}" | grep -o '[0-9]\+')" &&
NOT_UPDATED="$(grep -o '[0-9]\+ not upgraded' "${APT_OUTPUT}" | grep -o '[0-9]\+')"

if [ -z "${UPDATED}" ]; then
    UPDATED='0'
fi

if [ -z "${NOT_UPDATED}" ]; then
    NOT_UPDATED=0
fi

if [ "${UPDATED}" -gt '1' ]; then
    UPDATED_PLURAL='s'
else
    UPDATED_PLURAL=''
fi

if [ "${NOT_UPDATED}" -gt '1' ]; then
    NOT_UPDATED_PLURAL='s'
else
    NOT_UPDATED_PLURAL=''
fi


SUBJECT=''

if [ "${UPDATED}" -gt '0' ] && [ "${NOT_UPDATED}" -gt '0' ]; then
    SUBJECT="Installed ${UPDATED} update${UPDATED_PLURAL}; ${NOT_UPDATED} package${NOT_UPDATED_PLURAL} not updated"
elif [ "${UPDATED}" -gt '0' ]; then
    SUBJECT="Installed ${UPDATED} update${UPDATED_PLURAL}"
elif [ "${NOT_UPDATED}" -gt '0' ]; then
    SUBJECT="${NOT_UPDATED} package${NOT_UPDATED_PLURAL} not updated"
fi

if [ ! -z "${SUBJECT}" ]; then
    "${EMAIL_SCRIPT}" "${SUBJECT}" "$(cat "${APT_OUTPUT}")"
fi

echo "Updates finished at $(date)" >> "${LOG}" &&


cleanup
